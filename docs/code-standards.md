# Codebase Structure and Code Standards - chat-media-view

## Codebase Structure

The `chat-media-view` library follows a modular structure designed for clarity, maintainability, and scalability.

```
.
├── src/                  # Source code for the library
│   ├── components/       # React components (e.g., ChatMediaView)
│   ├── hooks/            # Custom React hooks
│   ├── utils/            # Utility functions
│   ├── types.ts          # TypeScript type definitions
│   └── index.ts          # Main entry point for the library
├── styles/               # Global styles or component-specific styles
│   └── chat-image-grid.css # CSS for the image grid
├── public/               # Public assets (e.g., example images for Storybook)
├── stories/              # Storybook stories for components
├── tests/                # Unit and integration tests
├── docs/                 # Project documentation
├── .github/              # GitHub Actions workflows, issue templates
├── .storybook/           # Storybook configuration
├── dist/                 # Compiled output (generated by Vite)
├── node_modules/         # Node.js dependencies
├── package.json          # Project metadata and dependencies
├── tsconfig.json         # TypeScript configuration
├── vite.config.ts        # Vite build configuration
├── vitest.config.ts      # Vitest test configuration
└── README.md             # Project README
```

## Code Standards and Best Practices

### 1. TypeScript Usage
- **Strict Typing**: Use TypeScript rigorously to ensure type safety.
- **Explicit Types**: Explicitly define types for function arguments, return values, and complex state where inference is not clear.
- **Interfaces for Objects**: Use interfaces for defining object shapes and props.

### 2. React Component Guidelines
- **Functional Components**: Prefer functional components with React Hooks.
- **Props Destructuring**: Destructure props at the component's top level for clarity.
- **Meaningful Naming**: Use clear and descriptive names for components, props, and state variables.
- **Prop Types (TypeScript)**: Rely on TypeScript interfaces for prop type checking.
- **State Management**: Use `useState` and `useReducer` for local component state. For global state, consider context API or a lightweight state management library if necessary (future consideration).
- **Side Effects**: Manage side effects using `useEffect`. Ensure proper dependency arrays to prevent unnecessary re-renders or stale closures.

### 3. Styling
- **CSS Modules**: Prefer CSS Modules for component-scoped styles to avoid global style conflicts.
- **BEM Naming (if not using CSS Modules)**: If global CSS is used, follow BEM (Block Element Modifier) conventions for class naming.
- **Variables**: Use CSS variables for themes, colors, and common spacing.

### 4. Naming Conventions
- **Files**: `PascalCase` for React components (`ComponentName.tsx`), `camelCase` for hooks and utilities (`useHookName.ts`, `utilityFunction.ts`).
- **Variables & Functions**: `camelCase`.
- **Constants**: `SCREAMING_SNAKE_CASE` for global constants.
- **Interfaces & Types**: `PascalCase`.

### 5. Error Handling
- **Boundary Components**: Implement error boundary components for gracefully handling rendering errors in React.
- **Meaningful Errors**: Provide clear error messages for debugging and user feedback.

### 6. Testing
- **Unit Tests**: Use Vitest and React Testing Library for unit testing components and utility functions.
- **Snapshot Tests**: Use snapshot tests for UI components to track changes in rendered output.
- **Coverage**: Strive for high test coverage for critical components and logic.

### 7. Documentation
- **Inline Comments**: Use comments for complex logic or explanations that aren't immediately obvious from the code.
- **JSDoc**: Use JSDoc for functions, components, and interfaces to generate API documentation.
- **Markdown Docs**: Maintain external documentation (like this file) in the `docs/` directory.

### 8. Performance
- **Memoization**: Use `React.memo`, `useMemo`, and `useCallback` to optimize performance for expensive computations or re-renders.
- **Lazy Loading**: Implement lazy loading for components or routes that are not immediately needed.

### 9. Version Control
- **Git Flow**: Follow a standard Git branching strategy (e.g., feature branches, develop, main).
- **Commit Messages**: Write clear, concise, and descriptive commit messages (e.g., Conventional Commits).
